<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="description" content="Soulify Chat - Anonymous conversations with strangers">
  <meta name="theme-color" content="#6366f1">
  <title>Soulify - Chat Room</title>
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <div id="chatContainer">
    <header>
      <img src="soulify-logo.png" alt="Soulify Logo" class="app-logo">
      <span class="soulify-text">Soulify</span>
      <div class="header-controls">
        <span id="onlineUsers">Online Users: <span id="onlineCount">0</span></span>
        <button id="videoCallBtn" class="neon-btn" disabled>📹 Video</button>
        <button id="endChat" class="neon-btn">End Chat</button>
        <button id="toggleMode" class="mode-btn">🌙</button>
      </div>
    </header>

    <!-- Main Content Area -->
    <div id="mainContent" class="main-content">
      <!-- Video Chat Section -->
      <div class="video-section" id="videoSection" style="display: none;">
        <div class="video-container">
          <video id="remoteVideo" autoplay playsinline></video>
          <video id="localVideo" autoplay muted playsinline></video>
        </div>
      </div>

      <!-- Chat Section -->
      <div id="chatSection" class="chat-section">
        <div id="chatBox"></div>
      </div>
    </div>
    <div id="typingIndicator"></div>

    <!-- Media Preview Modal -->
    <div id="mediaModal" class="media-modal" style="display: none;">
      <div class="modal-content">
        <span class="close-modal">&times;</span>
        <img id="modalImage" src="" alt="" style="display: none;">
        <video id="modalVideo" controls style="display: none;"></video>
        <audio id="modalAudio" controls style="display: none;"></audio>
      </div>
    </div>

    <!-- Voice Recording Popup -->
    <div id="voiceRecordingPopup" class="voice-recording-popup" style="display: none;">
      <h3>Recording Voice Message</h3>
      <div class="recording-animation">🎤</div>
      <div class="recording-time" id="recordingTime">00:00</div>
      <div class="recording-controls">
        <button id="stopRecordingPopup" class="popup-btn stop">Stop & Send</button>
        <button id="cancelRecordingPopup" class="popup-btn cancel">Cancel</button>
      </div>
    </div>

    <footer>
      <div class="input-section">
        <div class="media-controls">
          <button id="mediaBtn" class="media-btn" title="Share Image/Video">📷</button>
          <input type="file" id="mediaInput" accept="image/*,video/*" style="display: none;">
          <button id="voiceBtn" class="media-btn" title="Voice Message">🎤</button>
        </div>
        <textarea id="chatInput" placeholder="Type your message..." rows="3" disabled></textarea>
        <button id="sendBtn" disabled>Send</button>
      </div>

      <!-- Video Controls (shown when video chat is active) -->
      <div id="videoControls" class="video-controls" style="display: none;">
        <button id="toggleVideo" class="video-control-btn" title="Toggle Video">📹</button>
        <button id="toggleAudio" class="video-control-btn" title="Toggle Audio">🎤</button>
        <button id="endVideoCall" class="video-control-btn end-video" title="End Video Call">📞</button>
      </div>
      <div id="recordingIndicator" style="display: none;" class="recording-indicator">
        🔴 Recording... <button id="stopRecordingBtn">Stop</button>
      </div>
    </footer>
  </div>

  <!-- Video Call Request Popup -->
    <div id="videoCallPopup" class="video-call-popup" style="display: none;">
      <div class="video-call-modal">
        <div class="video-call-header">
          <div class="video-call-icon">📹</div>
          <h3 class="video-call-title">Incoming Video Call</h3>
        </div>
        <div class="caller-info">
          <p class="video-call-message">
            <span id="callerName">Unknown</span> wants to start a video call with you
          </p>
        </div>
        <div class="video-call-buttons">
          <button id="acceptVideoCall" class="video-call-btn accept-btn">
            <span class="btn-icon">✅</span>
            Accept
          </button>
          <button id="rejectVideoCall" class="video-call-btn reject-btn">
            <span class="btn-icon">❌</span>
            Reject
          </button>
        </div>
      </div>
    </div></div>

  <script>
    const socket = io();
    const chatBox = document.getElementById('chatBox');
    const typingIndicator = document.getElementById('typingIndicator');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const mediaBtn = document.getElementById('mediaBtn');
    const mediaInput = document.getElementById('mediaInput');
    const voiceBtn = document.getElementById('voiceBtn');
    const videoCallBtn = document.getElementById('videoCallBtn');
    const videoSection = document.getElementById('videoSection');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const mediaModal = document.getElementById('mediaModal');

    // Video Call Popup elements
    const videoCallPopup = document.getElementById('videoCallPopup');
    const callerNameSpan = document.getElementById('callerName');
    const acceptVideoCallBtn = document.getElementById('acceptVideoCall');
    const rejectVideoCallBtn = document.getElementById('rejectVideoCall');


    // Get username from localStorage or redirect to setup
    let currentUsername = localStorage.getItem('soulify_username');
    if (!currentUsername) {
      window.location.href = '/setup';
    } else {
      socket.emit('setUsername', currentUsername);
    }

    // Update online users count
    socket.on('updateOnlineUsers', (count) => {
      document.getElementById('onlineCount').textContent = count;
    });

    let partnerId;
    let partnerUsername = 'Stranger';
    let isConnected = false;
    let mediaRecorder;
    let recordedChunks = [];
    let localStream;
    let remoteStream;
    let peerConnection;
    let isVideoChatActive = false;

    // WebRTC configuration
    const rtcConfiguration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    // Initially disable input and send button
    chatInput.disabled = true;
    sendBtn.disabled = true;
    chatInput.placeholder = "Waiting for connection...";

    // Initiate chat
    socket.emit('startChat');

    // Send chat message
    const sendMessage = () => {
      if (!isConnected) {
        alert('Please wait until you are connected to a stranger!');
        return;
      }
      const message = chatInput.value.trim();
      if (message) {
        addMessageToChat('You', message, 'text');
        socket.emit('chatMessage', message);
        chatInput.value = '';
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    };

    const addMessageToChat = (sender, content, type) => {
      const messageDiv = document.createElement('div');
      let displaySender = sender;

      if (sender === 'You') {
        displaySender = currentUsername;
        messageDiv.className = 'message you';
      } else if (sender === 'Stranger') {
        displaySender = partnerUsername;
        messageDiv.className = 'message stranger';
      } else {
        messageDiv.className = 'message system';
      }

      if (type === 'text') {
        messageDiv.innerHTML = `<p>${displaySender}: ${content}</p>`;
      } else if (type === 'image') {
        messageDiv.innerHTML = `
          <p>${displaySender} sent an image:</p>
          <img src="${content}" alt="Shared image" class="shared-media" onclick="openMediaModal('${content}', 'image')">
        `;
      } else if (type === 'video') {
        messageDiv.innerHTML = `
          <p>${displaySender} sent a video:</p>
          <video src="${content}" class="shared-media" controls onclick="openMediaModal('${content}', 'video')"></video>
        `;
      } else if (type === 'voice') {
        messageDiv.innerHTML = `
          <p>${displaySender} sent a voice message:</p>
          <audio src="${content}" controls class="voice-message"></audio>
        `;
      }

      chatBox.appendChild(messageDiv);
      chatBox.scrollTop = chatBox.scrollHeight;
    };

    const openMediaModal = (src, type) => {
      const modal = document.getElementById('mediaModal');
      const modalImage = document.getElementById('modalImage');
      const modalVideo = document.getElementById('modalVideo');
      const modalAudio = document.getElementById('modalAudio');

      // Hide all media elements
      modalImage.style.display = 'none';
      modalVideo.style.display = 'none';
      modalAudio.style.display = 'none';

      if (type === 'image') {
        modalImage.src = src;
        modalImage.style.display = 'block';
      } else if (type === 'video') {
        modalVideo.src = src;
        modalVideo.style.display = 'block';
      } else if (type === 'audio') {
        modalAudio.src = src;
        modalAudio.style.display = 'block';
      }

      modal.style.display = 'flex';
    };

    // Media upload functionality
    mediaBtn.addEventListener('click', () => {
      if (!isConnected) {
        alert('Please wait until you are connected to a stranger!');
        return;
      }
      mediaInput.click();
    });

    mediaInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const formData = new FormData();
      formData.append('media', file);

      try {
        const response = await fetch('/upload', {
          method: 'POST',
          headers: {
            'user-id': socket.id
          },
          body: formData
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();

        if (response.ok) {
          const mediaType = file.type.startsWith('image/') ? 'image' : 'video';
          addMessageToChat('You', result.url, mediaType);

          socket.emit('mediaMessage', {
            type: mediaType,
            url: result.url,
            filename: result.originalname
          });
        } else {
          alert('Error uploading file: ' + result.error);
        }
      } catch (error) {
        alert('Error uploading file: ' + error.message);
      }
    });

    // Voice recording functionality
    let recordingTimer;
    let recordingStartTime;

    voiceBtn.addEventListener('click', async () => {
      if (!isConnected) {
        alert('Please wait until you are connected to a stranger!');
        return;
      }

      if (mediaRecorder && mediaRecorder.state === 'recording') {
        stopRecording();
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        recordedChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = async () => {
          const blob = new Blob(recordedChunks, { type: 'audio/webm' });
          const formData = new FormData();
          formData.append('media', blob, 'voice-message.webm');

          try {
            const response = await fetch('/upload', {
              method: 'POST',
              headers: {
                'user-id': socket.id
              },
              body: formData
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();

            if (response.ok) {
              addMessageToChat('You', result.url, 'voice');
              socket.emit('voiceMessage', {
                url: result.url
              });
            }
          } catch (error) {
            alert('Error uploading voice message: ' + error.message);
          }

          stream.getTracks().forEach(track => track.stop());
          hideVoiceRecordingPopup();
        };

        startRecording();

      } catch (error) {
        alert('Error accessing microphone: ' + error.message);
      }
    });

    const startRecording = () => {
      mediaRecorder.start();
      showVoiceRecordingPopup();
      recordingStartTime = Date.now();

      recordingTimer = setInterval(() => {
        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        document.getElementById('recordingTime').textContent = `${minutes}:${seconds}`;
      }, 1000);
    };

    const stopRecording = () => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        clearInterval(recordingTimer);
      }
    };

    const cancelRecording = () => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        recordedChunks = []; // Clear recorded data
        clearInterval(recordingTimer);
        hideVoiceRecordingPopup();
      }
    };

    const showVoiceRecordingPopup = () => {
      document.getElementById('voiceRecordingPopup').style.display = 'block';
      document.getElementById('recordingTime').textContent = '00:00';
    };

    const hideVoiceRecordingPopup = () => {
      document.getElementById('voiceRecordingPopup').style.display = 'none';
      clearInterval(recordingTimer);
    };

    // Popup button handlers
    document.getElementById('stopRecordingPopup').addEventListener('click', stopRecording);
    document.getElementById('cancelRecordingPopup').addEventListener('click', cancelRecording);

    document.getElementById('stopRecordingBtn').addEventListener('click', () => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
    });

    // Video call functionality
    videoCallBtn.addEventListener('click', async () => {
      if (!isConnected) {
        alert('Please wait until you are connected to a stranger!');
        return;
      }

      if (isVideoChatActive) {
        endVideoChat();
        return;
      }

      try {
        // Send video call request to partner
        socket.emit('videoCallRequest', {
          to: partnerId,
          from: currentUsername
        });
        addMessageToChat('System', 'Video call request sent...', 'text');
      } catch (error) {
        alert('Error sending video call request: ' + error.message);
      }
    });

    const startVideoChat = async () => {
      try {
        // Get user media first
        localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 320, max: 640 },
            height: { ideal: 240, max: 480 },
            frameRate: { ideal: 15, max: 30 }
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });

        // Set up local video
        localVideo.srcObject = localStream;
        localVideo.muted = true; // Ensure local video is muted to prevent feedback
        
        const playLocalVideo = () => {
          localVideo.play().then(() => {
            console.log('Local video playing successfully');
          }).catch(e => {
            console.log('Local video play error:', e);
            setTimeout(playLocalVideo, 500);
          });
        };
        
        localVideo.onloadedmetadata = playLocalVideo;
        localVideo.oncanplay = playLocalVideo;

        // Show video section
        videoSection.style.display = 'block';
        videoSection.classList.add('active');
        document.getElementById('mainContent').classList.add('video-active');
        document.getElementById('videoControls').style.display = 'flex';
        isVideoChatActive = true;
        videoCallBtn.textContent = '📹 End Video';

        // Create peer connection if it doesn't exist
        if (!peerConnection) {
          peerConnection = new RTCPeerConnection(rtcConfiguration);

          // Handle remote stream
          peerConnection.ontrack = (event) => {
            console.log('Received remote stream', event);
            if (event.streams && event.streams[0]) {
              remoteStream = event.streams[0];
              remoteVideo.srcObject = remoteStream;
              
              // Wait for video to be ready and then play
              const playRemoteVideo = () => {
                if (remoteVideo.readyState >= 2) {
                  remoteVideo.play().then(() => {
                    console.log('Remote video playing successfully');
                    addMessageToChat('System', 'Partner video connected', 'text');
                  }).catch(e => {
                    console.log('Remote video play error:', e);
                    setTimeout(playRemoteVideo, 500);
                  });
                } else {
                  setTimeout(playRemoteVideo, 100);
                }
              };
              
              remoteVideo.onloadedmetadata = playRemoteVideo;
              remoteVideo.oncanplay = playRemoteVideo;
              
              // Immediate attempt if already ready
              if (remoteVideo.readyState >= 2) {
                playRemoteVideo();
              }
            }
          };

          // Handle connection state changes
          peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', peerConnection.connectionState);
            if (peerConnection.connectionState === 'connected') {
              addMessageToChat('System', 'Video call connected successfully', 'text');
            } else if (peerConnection.connectionState === 'failed') {
              addMessageToChat('System', 'Connection failed. Attempting to reconnect...', 'text');
              // Attempt to restart ICE
              setTimeout(() => {
                if (peerConnection && peerConnection.connectionState === 'failed') {
                  if (peerConnection.restartIce) {
                    peerConnection.restartIce();
                  }
                }
              }, 1000);
            } else if (peerConnection.connectionState === 'disconnected') {
              addMessageToChat('System', 'Video call disconnected', 'text');
            } else if (peerConnection.connectionState === 'closed') {
              console.log('Peer connection closed');
            }
          };

          // Handle ICE connection state changes
          peerConnection.oniceconnectionstatechange = () => {
            console.log('ICE connection state:', peerConnection.iceConnectionState);
            if (peerConnection.iceConnectionState === 'failed') {
              addMessageToChat('System', 'Network connection failed. Retrying...', 'text');
              // Wait before restart to avoid rapid retries
              setTimeout(() => {
                if (peerConnection && peerConnection.iceConnectionState === 'failed') {
                  if (peerConnection.restartIce) {
                    peerConnection.restartIce();
                  }
                }
              }, 2000);
            } else if (peerConnection.iceConnectionState === 'connected') {
              console.log('ICE connected successfully');
              addMessageToChat('System', 'Connection established', 'text');
            } else if (peerConnection.iceConnectionState === 'completed') {
              console.log('ICE connection completed');
            } else if (peerConnection.iceConnectionState === 'checking') {
              console.log('ICE checking connections...');
            }
          };

          // Handle ICE gathering state changes
          peerConnection.onicegatheringstatechange = () => {
            console.log('ICE gathering state:', peerConnection.iceGatheringState);
          };

          // Handle ICE candidates with buffering
          let iceCandidateBuffer = [];
          let candidatesSent = false;
          
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              console.log('ICE candidate generated:', event.candidate.type);
              iceCandidateBuffer.push(event.candidate);
              
              // Send candidates immediately, but also buffer them
              socket.emit('ice-candidate', event.candidate);
            } else {
              // ICE gathering complete
              console.log('ICE gathering complete');
              candidatesSent = true;
            }
          };
        }

        // Add local stream tracks to peer connection
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });

        return peerConnection;
      } catch (error) {
        console.error('Error starting video chat:', error);
        addMessageToChat('System', 'Error accessing camera/microphone: ' + error.message, 'text');
        throw error;
      }
    };

    const endVideoChat = () => {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      videoSection.style.display = 'none';
      videoSection.classList.remove('active');
      document.getElementById('mainContent').classList.remove('video-active');
      document.getElementById('videoControls').style.display = 'none';
      isVideoChatActive = false;
      videoCallBtn.textContent = '📹 Video';
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      
      // Notify partner that video call ended
      socket.emit('endVideoCall');
      addMessageToChat('System', 'Video call ended', 'text');
    };

    // Video control buttons
    document.getElementById('toggleVideo').addEventListener('click', () => {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
          document.getElementById('toggleVideo').textContent = videoTrack.enabled ? '📹' : '📹❌';
          socket.emit('toggle-video', videoTrack.enabled);
        }
      }
    });

    document.getElementById('toggleAudio').addEventListener('click', () => {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          document.getElementById('toggleAudio').textContent = audioTrack.enabled ? '🎤' : '🎤❌';
          socket.emit('toggle-audio', audioTrack.enabled);
        }
      }
    });

    document.getElementById('endVideoCall').addEventListener('click', endVideoChat);

    sendBtn.addEventListener('click', sendMessage);

    // Send message on Enter key press
    chatInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    });

    // Socket event listeners
    socket.on('chatMessage', (msg) => {
      addMessageToChat('Stranger', msg, 'text');
      chatBox.scrollTop = chatBox.scrollHeight;
    });

    socket.on('mediaMessage', (data) => {
      addMessageToChat('Stranger', data.url, data.type);
      chatBox.scrollTop = chatBox.scrollHeight;
    });

    socket.on('voiceMessage', (data) => {
      addMessageToChat('Stranger', data.url, 'voice');
      chatBox.scrollTop = chatBox.scrollHeight;
    });

    // WebRTC signaling
    socket.on('offer', async (offer) => {
      try {
        // Ensure video chat is started
        if (!isVideoChatActive || !peerConnection) {
          await startVideoChat();
        }

        // Wait for peer connection to be ready and stable
        if (peerConnection && peerConnection.signalingState !== 'closed') {
          console.log('Setting remote description from offer');
          await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
          
          // Wait a moment for the connection to stabilize
          await new Promise(resolve => setTimeout(resolve, 100));
          
          console.log('Creating answer');
          const answer = await peerConnection.createAnswer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          });
          
          await peerConnection.setLocalDescription(answer);
          socket.emit('answer', answer);
          console.log('Answer sent successfully');
          addMessageToChat('System', 'Video call connecting...', 'text');
        }
      } catch (error) {
        console.error('Error handling offer:', error);
        addMessageToChat('System', 'Video call connection failed', 'text');
      }
    });

    socket.on('answer', async (answer) => {
      try {
        if (peerConnection && peerConnection.signalingState === 'have-local-offer') {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
          console.log('Answer set successfully');
        }
      } catch (error) {
        console.error('Error setting answer:', error);
      }
    });

    socket.on('ice-candidate', async (candidate) => {
      try {
        if (peerConnection && peerConnection.remoteDescription) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          console.log('ICE candidate added successfully');
        }
      } catch (error) {
        console.error('Error adding ICE candidate:', error);
      }
    });

    // Typing indicator (only when connected)
    chatInput.addEventListener('input', () => {
      if (isConnected) {
        socket.emit('typing');
      }
    });

    socket.on('typing', () => {
      typingIndicator.textContent = `${partnerUsername} is typing...`;
      setTimeout(() => {
        typingIndicator.textContent = '';
      }, 1000);
    });

    // Handle chat started
    socket.on('chatStarted', (partnerInfo) => {
      if (typeof partnerInfo === 'object') {
        partnerId = partnerInfo.partnerId;
        partnerUsername = partnerInfo.partnerUsername || 'Stranger';
      } else {
        // Fallback for old format
        partnerId = partnerInfo;
        partnerUsername = 'Stranger';
      }

      isConnected = true;
      chatInput.disabled = false;
      sendBtn.disabled = false;
      videoCallBtn.disabled = false;
      chatInput.placeholder = "Type a message...";
      addMessageToChat('System', `Connected to ${partnerUsername}`, 'text');
      chatInput.focus();
    });

    // Handle waiting status
    socket.on('waiting', () => {
      isConnected = false;
      chatInput.disabled = true;
      sendBtn.disabled = true;
      videoCallBtn.disabled = true;
      chatInput.placeholder = "Waiting for connection...";
      addMessageToChat('System', 'Looking for a stranger...', 'text');
    });

    // Handle chat ended
    socket.on('chatEnded', () => {
      isConnected = false;
      partnerUsername = 'Stranger';
      chatInput.disabled = true;
      sendBtn.disabled = true;
      videoCallBtn.disabled = true;
      endVideoChat();
      alert('Chat ended');
      window.location.href = '/home';
    });

    // End chat button
    const endChatBtn = document.getElementById('endChat');
    endChatBtn.addEventListener('click', () => {
      endVideoChat();
      socket.emit('endChat');
      window.location.href = '/home';
    });

    // Modal close functionality
    document.querySelector('.close-modal').addEventListener('click', () => {
      mediaModal.style.display = 'none';
    });

    mediaModal.addEventListener('click', (e) => {
      if (e.target === mediaModal) {
        mediaModal.style.display = 'none';
      }
    });

    // Dark/Light Mode Toggle
    const toggleButton = document.getElementById('toggleMode');
    toggleButton.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      if (document.body.classList.contains('dark-mode')) {
        toggleButton.innerHTML = '☀️';
      } else {
        toggleButton.innerHTML = '🌙';
      }
    });

    // Make local video draggable on mobile
    let isDragging = false;
    let startX, startY, startLeft, startTop;

    localVideo.addEventListener('mousedown', startDrag);
    localVideo.addEventListener('touchstart', startDrag, { passive: false });

    function startDrag(e) {
      if (window.innerWidth <= 768 && isVideoChatActive) {
        isDragging = true;
        localVideo.classList.add('dragging');

        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

        startX = clientX;
        startY = clientY;
        startLeft = localVideo.offsetLeft;
        startTop = localVideo.offsetTop;

        e.preventDefault();
      }
    }

    document.addEventListener('mousemove', drag);
    document.addEventListener('touchmove', drag, { passive: false });

    function drag(e) {
      if (!isDragging) return;

      const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
      const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

      const deltaX = clientX - startX;
      const deltaY = clientY - startY;

      const newLeft = startLeft + deltaX;
      const newTop = startTop + deltaY;

      const container = localVideo.parentElement;
      const maxLeft = container.clientWidth - localVideo.offsetWidth;
      const maxTop = container.clientHeight - localVideo.offsetHeight;

      localVideo.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
      localVideo.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';

      e.preventDefault();
    }

    document.addEventListener('mouseup', stopDrag);
    document.addEventListener('touchend', stopDrag);

    function stopDrag() {
      if (isDragging) {
        isDragging = false;
        localVideo.classList.remove('dragging');
      }
    }

    // Video Call Request Popup Handlers
    socket.on('incomingCall', (callerInfo) => {
      console.log('Incoming call from:', callerInfo);
      callerNameSpan.textContent = callerInfo.username || 'Unknown';
      videoCallPopup.style.display = 'flex';
    });

    acceptVideoCallBtn.addEventListener('click', async () => {
      videoCallPopup.style.display = 'none';
      
      try {
        // Start video chat first
        await startVideoChat();
        
        // Then notify partner that call is accepted
        socket.emit('acceptCall', { to: partnerId });
        addMessageToChat('System', 'Video call accepted. Connecting...', 'text');
      } catch (error) {
        console.error('Error accepting video call:', error);
        addMessageToChat('System', 'Failed to accept video call', 'text');
      }
    });

    rejectVideoCallBtn.addEventListener('click', () => {
      videoCallPopup.style.display = 'none';
      socket.emit('rejectCall', { to: partnerId });
    });

    socket.on('callAccepted', async () => {
      try {
        // Start video chat if not already started
        if (!isVideoChatActive) {
          await startVideoChat();
        }
        
        // Wait for ICE gathering to complete
        await new Promise(resolve => {
          if (peerConnection.iceGatheringState === 'complete') {
            resolve();
          } else {
            const checkIceGathering = () => {
              if (peerConnection.iceGatheringState === 'complete') {
                peerConnection.removeEventListener('icegatheringstatechange', checkIceGathering);
                resolve();
              }
            };
            peerConnection.addEventListener('icegatheringstatechange', checkIceGathering);
            // Fallback timeout
            setTimeout(resolve, 3000);
          }
        });
        
        // Create and send offer after ICE gathering
        if (peerConnection && peerConnection.signalingState === 'stable') {
          const offer = await peerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          });
          await peerConnection.setLocalDescription(offer);
          socket.emit('offer', offer);
          console.log('Offer sent successfully');
        }
        
        addMessageToChat('System', 'Video call connecting...', 'text');
        
        // Set a connection timeout with retry
        let connectionTimeout = setTimeout(() => {
          if (peerConnection && peerConnection.connectionState !== 'connected') {
            console.log('First connection attempt timed out, retrying...');
            addMessageToChat('System', 'Retrying connection...', 'text');
            
            // Retry connection
            if (peerConnection.restartIce) {
              peerConnection.restartIce();
            } else {
              // Fallback: create new offer
              peerConnection.createOffer({
                iceRestart: true,
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              }).then(offer => {
                return peerConnection.setLocalDescription(offer);
              }).then(() => {
                socket.emit('offer', peerConnection.localDescription);
              }).catch(console.error);
            }
          }
        }, 8000);
        
        // Clear timeout when connected
        peerConnection.addEventListener('connectionstatechange', () => {
          if (peerConnection.connectionState === 'connected') {
            clearTimeout(connectionTimeout);
          }
        });
        
      } catch (error) {
        console.error('Error starting video call:', error);
        addMessageToChat('System', 'Failed to connect video call', 'text');
      }
    });

    socket.on('callRejected', () => {
      addMessageToChat('System', 'Video call rejected', 'text');
    });

    // Handle toggled video/audio
    socket.on('videoToggled', (enabled) => {
      if (remoteVideo.srcObject) {
        const remoteTracks = remoteVideo.srcObject.getTracks();
        const videoTrack = remoteTracks.find(track => track.kind === 'video');
        if (videoTrack) {
          videoTrack.enabled = enabled;
        }
      }
    });

    socket.on('audioToggled', (enabled) => {
      if (remoteVideo.srcObject) {
        const remoteTracks = remoteVideo.srcObject.getTracks();
        const audioTrack = remoteTracks.find(track => track.kind === 'audio');
        if (audioTrack) {
          audioTrack.enabled = enabled;
        }
      }
    });
  </script>
</body>
</html>